<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Gesture Particle Playground (Final Advanced)</title>
    <style>
        /* Minimal, Modern CSS */
        body { margin: 0; overflow: hidden; background-color: #000; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
        #container { position: absolute; width: 100%; height: 100%; z-index: 1; }
        #video-overlay { position: absolute; top: 0; left: 0; visibility: hidden; z-index: 0; width: 100%; height: 100%; }
        #ui-controls {
            position: absolute; top: 10px; right: 10px; z-index: 10;
            background: rgba(10, 10, 20, 0.9);
            padding: 15px; border-radius: 12px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.7);
            color: #fff; max-width: 320px;
        }
        .ui-section { margin-bottom: 15px; padding: 10px 0; border-top: 1px solid rgba(255, 255, 255, 0.1); }
        .ui-section:first-child { border-top: none; }
        .ui-section h4 { margin: 5px 0 10px 0; font-weight: 600; font-size: 1.1em; color: #4CAF50; }
        .ui-section label { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; font-size: 0.9em; }
        .ui-section input[type="range"], .ui-section input[type="color"] { flex-shrink: 0; margin-left: 10px; width: 120px; }
        .ui-section input[type="color"] { height: 25px; }
        .template-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 10px; }
        .template-button {
            padding: 10px 5px; background: rgba(50, 50, 70, 0.7); color: #fff;
            border: none; border-radius: 6px; cursor: pointer; font-size: 0.8em;
            transition: background 0.2s, transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        .template-button:hover { background: rgba(70, 70, 90, 0.9); transform: translateY(-1px); }
        .template-button.active { background: #4caf50; font-weight: bold; box-shadow: 0 0 10px #4caf5077; }
        #readme {
            position: absolute; bottom: 10px; left: 10px; z-index: 10;
            background: rgba(10, 10, 20, 0.85); color: #ccc;
            padding: 15px; border-radius: 8px; max-width: 350px; font-size: 0.85em;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        #readme p { margin: 5px 0; }
        .camera-error {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ff4444; background: rgba(0, 0, 0, 0.8); padding: 25px;
            border-radius: 10px; text-align: center; z-index: 20;
            box-shadow: 0 0 15px rgba(255, 68, 68, 0.5);
        }
        .slider-value { font-size: 0.8em; color: #aaa; margin-left: 5px; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js"></script>
</head>
<body>
    <div id="container"></div>
    <video id="video-overlay" style="display: none;" autoplay playsinline></video>

    <div id="ui-controls">
        <h3>âœ¨ Particle Playground</h3>

        <div class="ui-section">
            <h4>Template Selection</h4>
            <div id="template-grid" class="template-grid">
                </div>
        </div>

        <div class="ui-section">
            <h4>Color & Visuals</h4>
            <label>
                Particle Color
                <input type="color" id="color-picker" value="#00ffaa">
            </label>
            <label>
                Particle Size
                <input type="range" id="size-slider" min="0.5" max="10.0" step="0.1" value="3.0">
            </label>
            <label>
                Particle Count (Active)
                <span id="particle-count-display" class="slider-value">50000</span>
            </label>
        </div>

        <div class="ui-section">
            <h4>Motion & Physics</h4>
            <label>
                Center Attraction
                <input type="range" id="attraction-slider" min="0.0" max="1.0" step="0.01" value="0.1">
            </label>
            <label>
                Motion Noise Strength
                <input type="range" id="noise-slider" min="0.0" max="0.5" step="0.01" value="0.05">
            </label>
            <label>
                Velocity Dampening
                <input type="range" id="dampening-slider" min="0.9" max="0.999" step="0.001" value="0.950">
            </label>
        </div>

        <div class="ui-section">
            <h4>Controls</h4>
            <label>
                Enable Gesture Control
                <input type="checkbox" id="gesture-toggle" checked>
            </label>
            <label>
                Manual Spread (Fallback)
                <input type="range" id="spread-manual" min="0.1" max="5.0" step="0.01" value="1.0">
            </label>
        </div>
    </div>

    <div id="readme">
        <h4>README: Controls & Gestures</h4>
        <p>1. **Gesture Control (Needs Camera)**: Turn on "Enable Gesture Control".</p>
        <ul>
            <li>**Tension (Fingers Spread vs. Fist)**: Controls the particle **spread/expansion**.</li>
            <li>**Color Breathing**: Hold a **Fist** (low tension) to slowly cycle colors. Release the fist for a **Color Burst**!</li>
            <li>**Hand Distance**: Controls the global particle **scale**.</li>
            <li>**Fireworks Template**: A quick closing motion (snap) triggers a burst.</li>
        </ul>
        <p>2. **Performance**: Default active count is 50k. If slow, check browser console for WebGL warnings.</p>
    </div>

    <script>
        // --- Core Configuration and Constants ---
        const MAX_PARTICLE_COUNT = 150000;
        const DEFAULT_PARTICLE_COUNT = 50000;
        let currentParticleCount = DEFAULT_PARTICLE_COUNT;
        
        // Particle Templates: Define initial positions and behavior
        const PARTICLE_TEMPLATES = {
            'Heart': {
                name: 'Heart',
                init_fn: (posAttr, particleCount) => {
                    for (let i = 0; i < particleCount; i++) {
                        let r = Math.sqrt(Math.random()) * 2;
                        let a = Math.random() * Math.PI * 2;
                        let x = r * Math.cos(a) * 10;
                        let y = r * Math.sin(a) * 10;
                        posAttr.setX(i, x);
                        posAttr.setY(i, y + 5);
                        posAttr.setZ(i, (Math.random() - 0.5) * 5);
                    }
                }
            },
            'Flowers': {
                name: 'Flowers',
                init_fn: (posAttr, particleCount) => {
                    for (let i = 0; i < particleCount; i++) {
                        const r = Math.random() * 20;
                        const a = Math.random() * Math.PI * 2;
                        posAttr.setX(i, r * Math.cos(a));
                        posAttr.setY(i, (Math.random() - 0.5) * 5);
                        posAttr.setZ(i, r * Math.sin(a));
                    }
                }
            },
            'Saturn': {
                name: 'Saturn',
                init_fn: (posAttr, particleCount) => {
                    for (let i = 0; i < particleCount; i++) {
                        if (Math.random() < 0.6) { 
                            const r = Math.random() * 8;
                            const theta = Math.random() * Math.PI * 2;
                            const phi = Math.acos(Math.random() * 2 - 1);
                            posAttr.setX(i, r * Math.sin(phi) * Math.cos(theta));
                            posAttr.setY(i, r * Math.sin(phi) * Math.sin(theta));
                            posAttr.setZ(i, r * Math.cos(phi));
                        } else {
                            const r = THREE.MathUtils.randFloat(10, 16);
                            const theta = Math.random() * Math.PI * 2;
                            posAttr.setX(i, r * Math.cos(theta));
                            posAttr.setY(i, (Math.random() - 0.5) * 0.1); 
                            posAttr.setZ(i, r * Math.sin(theta));
                        }
                    }
                }
            },
            'Buddha': {
                name: 'Buddha',
                init_fn: (posAttr, particleCount) => {
                    for (let i = 0; i < particleCount; i++) {
                        const r = Math.random() * 5;
                        const theta = Math.random() * Math.PI * 2;
                        posAttr.setX(i, r * Math.cos(theta));
                        posAttr.setY(i, THREE.MathUtils.randFloat(-15, 15));
                        posAttr.setZ(i, r * Math.sin(theta));
                    }
                }
            },
            'Fireworks': {
                name: 'Fireworks',
                init_fn: (posAttr, particleCount) => {
                    for (let i = 0; i < particleCount; i++) {
                        posAttr.setX(i, 0);
                        posAttr.setY(i, 0);
                        posAttr.setZ(i, 0);
                    }
                }
            }
        };

        // --- GLSL Shaders for GPU efficiency ---
        const particleVertexShader = `
            uniform float u_time;
            uniform float u_size;
            uniform float u_spread;
            uniform float u_scale;
            uniform float u_noiseStrength;
            uniform float u_attractionStrength;
            uniform vec3 u_center;

            attribute vec3 a_startPosition;
            attribute vec3 a_velocity;
            attribute float a_birthTime;

            varying vec3 v_color;

            // Hash function for random-like noise (works well in GLSL)
            float hash(float n) { return fract(sin(n) * 43758.5453); }
            vec3 hash3(vec3 p) {
                return fract(sin(vec3(dot(p, vec3(1.0, 57.0, 113.0)),
                                      dot(p, vec3(57.0, 113.0, 1.0)),
                                      dot(p, vec3(113.0, 1.0, 57.0)))) * 43758.5453);
            }
            
            // Simple 3D noise (fast, stable, and guaranteed to compile)
            float snoise3(vec3 p) {
                return (hash(p.x * 10.0 + hash(p.y * 10.0 + hash(p.z * 10.0))) - 0.5) * 2.0;
            }

            void main() {
                v_color = color;
                
                vec3 finalPosition = a_startPosition;
                float age = u_time - a_birthTime;

                // 1. Velocity and Dampening (Simulated Integration)
                vec3 currentVelocity = a_velocity;
                finalPosition += currentVelocity * age;

                // 2. Center Attraction Force
                vec3 displacement = finalPosition - u_center;
                float dist = length(displacement);
                
                // Attraction/Repulsion
                vec3 attraction = -normalize(displacement) * u_attractionStrength * 0.05 / max(dist, 1.0);
                finalPosition += attraction * age * 0.1; 

                // 3. Per-particle noise for organic motion (Fixed using snoise3)
                vec3 noise = vec3(
                    snoise3(finalPosition * 0.1 + u_time * 0.2),
                    snoise3(finalPosition * 0.1 + u_time * 0.2 + 10.0),
                    snoise3(finalPosition * 0.1 + u_time * 0.2 + 20.0)
                ) * u_noiseStrength * 5.0;
                finalPosition += noise;
                
                // 4. Apply Gesture Mappings (Spread and Scale)
                finalPosition = u_center + (finalPosition - u_center) * u_spread;
                finalPosition *= u_scale;

                // 5. Final Projection
                vec4 mvPosition = modelViewMatrix * vec4( finalPosition, 1.0 );

                // 6. Size
                gl_PointSize = u_size * ( 1.0 / -mvPosition.z );
                
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const particleFragmentShader = `
            uniform vec3 u_baseColor;
            uniform float u_breatheMix; 
            uniform vec3 u_breatheColor;

            varying vec3 v_color;

            void main() {
                // Circular particle shape
                float r = 0.0;
                vec2 cxy = 2.0 * gl_PointCoord - 1.0;
                r = dot(cxy, cxy);

                // Stronger glow/fade 
                float alpha = pow(1.0 - r, 4.0);
                
                // Mix the base color with the breathing color
                vec3 finalColor = mix(u_baseColor, u_breatheColor, u_breatheMix);
                
                // Apply vertex color (v_color) for intensity/fireworks fade
                gl_FragColor = vec4( finalColor * v_color, alpha );
            }
        `;

        // --- Three.js Setup Variables ---
        let scene, camera, renderer, particles;
        let clock = new THREE.Clock();

        // --- Particle State and Attributes ---
        let geometry, material;
        let attributes = {
            a_startPosition: new THREE.BufferAttribute(new Float32Array(MAX_PARTICLE_COUNT * 3), 3),
            a_velocity: new THREE.BufferAttribute(new Float32Array(MAX_PARTICLE_COUNT * 3), 3),
            a_birthTime: new THREE.BufferAttribute(new Float32Array(MAX_PARTICLE_COUNT), 1),
            color: new THREE.BufferAttribute(new Float32Array(MAX_PARTICLE_COUNT * 3), 3),
        };
        let particleSettings = {
            template: 'Heart',
            baseColor: new THREE.Color(0x00ffaa),
            size: 3.0,
            spread: 1.0,
            scale: 1.0,
            noiseStrength: 0.05,
            dampening: 0.950,
            attractionStrength: 0.1,
        };

        // --- Color Breathing State ---
        let breathing = false;
        let breatheMixTarget = 0.0;
        let breatheTime = 0.0;
        const tempColor = new THREE.Color();
        const baseColorCache = new THREE.Color(0x00ffaa);


        // --- MediaPipe and Gesture Variables ---
        let videoElement;
        let hands;
        let isCameraReady = false;
        let currentHandData = [];
        let prevTension = 0.0;
        let lastBurstTime = 0;
        const GESTURE_SETTINGS = {
            tensionMin: 0.05,
            tensionMax: 0.25,
            tensionHoldThreshold: 0.1, 
            spreadLerpFactor: 0.1,
            scaleLerpFactor: 0.05,
            fireworksSnapThreshold: 0.05,
        };

        // --- Utility Functions ---
        const mapRange = (value, min1, max1, min2, max2) => {
            value = Math.min(Math.max(value, min1), max1);
            return min2 + (max2 - min2) * ((value - min1) / (max1 - min1));
        };
        const lerp = (a, b, t) => a + (b - a) * t;

        // --- Three.js Functions ---

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            initParticles();
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function initParticles() {
            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', attributes.a_startPosition);
            geometry.setAttribute('a_startPosition', attributes.a_startPosition);
            geometry.setAttribute('a_velocity', attributes.a_velocity);
            geometry.setAttribute('a_birthTime', attributes.a_birthTime);
            geometry.setAttribute('color', attributes.color);
            geometry.setDrawRange(0, currentParticleCount); // Set initial draw count

            material = new THREE.ShaderMaterial({
                uniforms: {
                    u_time: { value: 0.0 },
                    u_baseColor: { value: particleSettings.baseColor },
                    u_size: { value: particleSettings.size },
                    u_spread: { value: particleSettings.spread },
                    u_scale: { value: particleSettings.scale },
                    u_noiseStrength: { value: particleSettings.noiseStrength },
                    u_attractionStrength: { value: particleSettings.attractionStrength },
                    u_center: { value: new THREE.Vector3(0, 0, 0) },
                    u_breatheMix: { value: 0.0 }, 
                    u_breatheColor: { value: new THREE.Color() },
                },
                vertexShader: particleVertexShader,
                fragmentShader: particleFragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            setParticleTemplate(particleSettings.template);
        }

        function setParticleTemplate(templateName) {
            const template = PARTICLE_TEMPLATES[templateName];
            if (!template) return;

            particleSettings.template = templateName;

            document.querySelectorAll('.template-button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.template === templateName);
            });

            const posAttr = attributes.a_startPosition;
            const velAttr = attributes.a_velocity;
            const birthAttr = attributes.a_birthTime;

            template.init_fn(posAttr, MAX_PARTICLE_COUNT); // Use MAX count for initializing buffer
            posAttr.needsUpdate = true;
            
            for (let i = 0; i < currentParticleCount * 3; i++) {
                velAttr.array[i] = 0;
            }
            for (let i = 0; i < currentParticleCount; i++) {
                birthAttr.array[i] = clock.getElapsedTime();
            }
            velAttr.needsUpdate = true;
            birthAttr.needsUpdate = true;
        }

        function triggerColorBurst() {
            material.uniforms.u_breatheMix.value = 1.0;
            // Set the burst color (bright white for maximum impact)
            material.uniforms.u_breatheColor.value.set(0xffffff); 
            breatheMixTarget = 0.0;
        }

        function updateColorBreathing(delta) {
            breatheTime += delta;
            
            if (breathing) {
                // Cycle through hue slowly (6 seconds per cycle)
                const hue = (breatheTime / 6.0) % 1.0;
                tempColor.setHSL(hue, 1.0, 0.5);
                
                breatheMixTarget = 1.0;
                material.uniforms.u_breatheColor.value.copy(tempColor);
            }

            material.uniforms.u_breatheMix.value = lerp(
                material.uniforms.u_breatheMix.value, 
                breatheMixTarget, 
                breathing ? 0.05 : 0.03 
            );

            if (!breathing && material.uniforms.u_breatheMix.value < 0.01) {
                material.uniforms.u_breatheMix.value = 0.0;
                material.uniforms.u_breatheColor.value.copy(baseColorCache);
            }
        }

        function triggerFireworksBurst(velocity = 70) {
            if (particleSettings.template !== 'Fireworks') return;

            const velAttr = attributes.a_velocity;
            const birthAttr = attributes.a_birthTime;
            const colors = attributes.color;
            const currentTime = clock.getElapsedTime();

            for (let i = 0; i < currentParticleCount; i++) {
                const v = new THREE.Vector3(
                    Math.random() * 2 - 1,
                    Math.random() * 2 - 1,
                    Math.random() * 2 - 1
                ).normalize().multiplyScalar(velocity * (0.8 + Math.random() * 0.4));

                velAttr.setX(i, v.x);
                velAttr.setY(i, v.y);
                velAttr.setZ(i, v.z);

                birthAttr.setX(i, currentTime);
                colors.setX(i, 1.0);
                colors.setY(i, 1.0);
                colors.setZ(i, 1.0);
            }

            velAttr.needsUpdate = true;
            birthAttr.needsUpdate = true;
            colors.needsUpdate = true;
            lastBurstTime = currentTime;
        }

        function updateParticles(delta) {
            const time = clock.getElapsedTime();
            material.uniforms.u_time.value = time;

            const velAttr = attributes.a_velocity;
            const damp = particleSettings.dampening;
            const rotationFactor = 0.0005;

            for (let i = 0; i < currentParticleCount; i++) {
                const i3 = i * 3;
                velAttr.array[i3] *= damp;
                velAttr.array[i3 + 1] *= damp;
                velAttr.array[i3 + 2] *= damp;

                if (particleSettings.template !== 'Fireworks') {
                    const x = attributes.a_startPosition.getX(i);
                    const z = attributes.a_startPosition.getZ(i);
                    
                    const vx = velAttr.getX(i) + (-z * rotationFactor);
                    const vz = velAttr.getZ(i) + (x * rotationFactor);

                    velAttr.setX(i, vx);
                    velAttr.setZ(i, vz);
                }
            }
            velAttr.needsUpdate = true;
            
            updateColorBreathing(delta);

            // Smoothly transition uniforms (LERP)
            material.uniforms.u_size.value = lerp(material.uniforms.u_size.value, particleSettings.size, 0.1);
            material.uniforms.u_spread.value = lerp(material.uniforms.u_spread.value, particleSettings.spread, GESTURE_SETTINGS.spreadLerpFactor);
            material.uniforms.u_scale.value = lerp(material.uniforms.u_scale.value, particleSettings.scale, GESTURE_SETTINGS.scaleLerpFactor);
            material.uniforms.u_noiseStrength.value = lerp(material.uniforms.u_noiseStrength.value, particleSettings.noiseStrength, 0.1);
            material.uniforms.u_attractionStrength.value = lerp(material.uniforms.u_attractionStrength.value, particleSettings.attractionStrength, 0.1);
            material.uniforms.u_baseColor.value.copy(baseColorCache);

            // Particle Fade for Fireworks
            if (particleSettings.template === 'Fireworks') {
                const colors = attributes.color;
                const birthAttr = attributes.a_birthTime;
                for (let i = 0; i < currentParticleCount; i++) {
                    const age = time - birthAttr.getX(i);
                    const fade = Math.max(0, 1 - age / 3.0); 
                    colors.setX(i, fade);
                    colors.setY(i, fade);
                    colors.setZ(i, fade);
                }
                colors.needsUpdate = true;
            }
        }

        // --- MediaPipe Functions ---
        async function initCamera() {
            // ... (Camera initialization logic remains the same)
            videoElement = document.getElementById('video-overlay');
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } });
                videoElement.srcObject = stream;
                await new Promise((resolve) => { videoElement.onloadedmetadata = resolve; });
                videoElement.play();
                isCameraReady = true;

                hands = new Hands({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`,
                });
                hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5, });
                hands.onResults(onHandsResults);

                new Camera(videoElement, {
                    onFrame: async () => {
                        if (document.getElementById('gesture-toggle').checked && videoElement.readyState === 4) {
                            await hands.send({ image: videoElement });
                        }
                    },
                    width: 1280,
                    height: 720
                }).start();

            } catch (error) {
                console.error("Camera access failed:", error);
                document.body.insertAdjacentHTML('beforeend',
                    `<div class="camera-error"><h4>Camera Access Required for Gesture Control</h4><p>Please enable camera access and reload, or use the manual controls.</p></div>`
                );
                document.getElementById('gesture-toggle').checked = false;
            }
        }

        function onHandsResults(results) {
            currentHandData = results.multiHandLandmarks || [];
        }

        function calculateTension(hand) {
            if (!hand || hand.length < 21) return 0;
            const wrist = hand[0];
            let totalDistance = 0;
            const fingerTips = [4, 8, 12, 16, 20];
            fingerTips.forEach(idx => {
                const tip = hand[idx];
                const dx = tip.x - wrist.x;
                const dy = tip.y - wrist.y;
                const dz = tip.z - wrist.z;
                totalDistance += Math.sqrt(dx * dx + dy * dy + dz * dz);
            });
            return (totalDistance / fingerTips.length) * 2;
        }

        function calculateGestureInput() {
            const isGestureControl = document.getElementById('gesture-toggle').checked;
            let targetSpread = 1.0;
            let targetScale = 1.0;
            let currentTension = 1.0;

            if (isGestureControl && currentHandData.length > 0) {
                const hand1 = currentHandData[0];
                currentTension = calculateTension(hand1);
                targetSpread = mapRange(currentTension, GESTURE_SETTINGS.tensionMin, GESTURE_SETTINGS.tensionMax, 0.1, 5.0);

                // --- COLOR BREATHING LOGIC ---
                const isFist = currentTension < GESTURE_SETTINGS.tensionHoldThreshold;
                const wasFist = prevTension < GESTURE_SETTINGS.tensionHoldThreshold;

                if (isFist) {
                    if (!breathing) breatheTime = 0.0;
                    breathing = true;
                } else if (wasFist) {
                    breathing = false;
                    triggerColorBurst();
                } else {
                    breathing = false;
                    breatheMixTarget = 0.0;
                }
                
                // Fireworks Snap Detection 
                const tensionDelta = prevTension - currentTension;
                if (particleSettings.template === 'Fireworks' && tensionDelta > GESTURE_SETTINGS.fireworksSnapThreshold && clock.getElapsedTime() - lastBurstTime > 0.5) {
                    triggerFireworksBurst();
                }
                prevTension = currentTension;

                // Hands Distance (Global Scale)
                if (currentHandData.length === 2) {
                    const hand2 = currentHandData[1];
                    const wrist1 = hand1[0];
                    const wrist2 = hand2[0];
                    const dx = wrist1.x - wrist2.x;
                    const dy = wrist1.y - wrist2.y;
                    const distance = Math.sqrt(dx * dx + dy * dy); 
                    targetScale = mapRange(distance, 0.2, 1.0, 0.8, 1.2);
                }

                particleSettings.spread = targetSpread;
                particleSettings.scale = targetScale;

            } else {
                particleSettings.spread = parseFloat(document.getElementById('spread-manual').value);
                prevTension = 1.0;
                particleSettings.scale = 1.0;
                breathing = false;
                breatheMixTarget = 0.0;
            }

            if (isGestureControl) {
                document.getElementById('spread-manual').value = particleSettings.spread.toFixed(2);
            }
        }

        // --- UI and Input Handlers ---
        function setupUI() {
            const grid = document.getElementById('template-grid');
            Object.keys(PARTICLE_TEMPLATES).forEach(key => {
                const btn = document.createElement('button');
                btn.className = 'template-button';
                btn.dataset.template = key;
                btn.textContent = PARTICLE_TEMPLATES[key].name;
                btn.onclick = () => setParticleTemplate(key);
                grid.appendChild(btn);
            });
            document.querySelector(`[data-template="${particleSettings.template}"]`).classList.add('active');

            document.getElementById('color-picker').oninput = (e) => {
                particleSettings.baseColor.set(e.target.value);
                baseColorCache.copy(particleSettings.baseColor); 
            };
            document.getElementById('size-slider').oninput = (e) => {
                particleSettings.size = parseFloat(e.target.value);
            };
            document.getElementById('attraction-slider').oninput = (e) => {
                particleSettings.attractionStrength = parseFloat(e.target.value);
            };
            document.getElementById('noise-slider').oninput = (e) => {
                particleSettings.noiseStrength = parseFloat(e.target.value);
            };
            document.getElementById('dampening-slider').oninput = (e) => {
                particleSettings.dampening = parseFloat(e.target.value);
            };
            document.getElementById('gesture-toggle').onchange = (e) => {
                if (e.target.checked && !isCameraReady) {
                    e.target.checked = false;
                    alert("Camera not ready. Please check permissions and reload.");
                }
                document.getElementById('spread-manual').disabled = e.target.checked;
            };

            document.getElementById('spread-manual').disabled = document.getElementById('gesture-toggle').checked;
            
            baseColorCache.copy(particleSettings.baseColor);
        }

        // --- Main Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            calculateGestureInput();
            updateParticles(delta);
            renderer.render(scene, camera);
        }

        // --- Initialization on Load ---
        window.onload = () => {
            currentParticleCount = DEFAULT_PARTICLE_COUNT;
            document.getElementById('particle-count-display').textContent = currentParticleCount;

            initThree();
            setupUI();
            initCamera(); 
            animate();
        };

    </script>
</body>
</html>

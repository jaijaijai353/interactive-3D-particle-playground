<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Gesture Starfield â€“ Reel Style</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Three.js r149 (pre-r150, examples attach to global THREE) -->
  <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
  <!-- Post-processing examples for r149 -->
  <script src="https://unpkg.com/three@0.149.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://unpkg.com/three@0.149.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://unpkg.com/three@0.149.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

  <!-- MediaPipe Hands (hand-pose model). Can be swapped to another model. -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

  <style>
    :root {
      --bg: #000000;
      --accent: #f5f1e8;
      --accent-soft: rgba(245, 241, 232, 0.15);
      --border-subtle: rgba(255, 255, 255, 0.08);
      --text-main: #f7f7ff;
      --text-muted: #9da2c0;
      --radius-lg: 16px;
      --shadow-soft: 0 18px 40px rgba(0, 0, 0, 0.8);
      --transition-fast: 0.18s ease-out;
      --danger: #ff5b6b;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      margin: 0;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
      background: #000;
      color: var(--text-main);
    }

    #app {
      position: fixed;
      inset: 0;
    }

    #three-container {
      position: absolute;
      inset: 0;
      overflow: hidden;
      background: #000;
    }

    canvas {
      display: block;
    }

    /* Hidden webcam video (used only for hand detection) */
    #input-video {
      position: fixed;
      inset: auto auto 10px 10px;
      width: 120px;
      opacity: 0;
      pointer-events: none;
    }

    /* Minimal UI overlay */
    #ui-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 12px 14px;
      z-index: 10;
    }

    #top-left-chip {
      align-self: flex-start;
      pointer-events: auto;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.12);
      backdrop-filter: blur(18px);
      box-shadow: var(--shadow-soft);
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 0.78rem;
      color: var(--text-muted);
    }

    #top-left-chip span.dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: #10ffca;
      box-shadow: 0 0 12px rgba(16, 255, 202, 0.9);
    }

    #bottom-controls {
      align-self: center;
      pointer-events: auto;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.65);
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(18px);
      box-shadow: var(--shadow-soft);
      margin-bottom: 8px;
    }

    .btn {
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 0.78rem;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(255, 255, 255, 0.02);
      color: var(--text-main);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: background var(--transition-fast), border-color var(--transition-fast),
        transform var(--transition-fast), box-shadow var(--transition-fast), color var(--transition-fast);
    }

    .btn:hover {
      background: rgba(255, 255, 255, 0.06);
      transform: translateY(-1px);
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.7);
    }

    .btn:active {
      transform: translateY(0);
      box-shadow: none;
    }

    .btn-toggle-on {
      border-color: rgba(16, 255, 202, 0.8);
      color: #10ffca;
      box-shadow: 0 0 0 1px rgba(16, 255, 202, 0.5);
    }

    #density-group {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.78rem;
      color: var(--text-muted);
    }

    #density-slider {
      width: 90px;
      appearance: none;
      height: 3px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.18);
      outline: none;
    }

    #density-slider::-webkit-slider-thumb {
      appearance: none;
      width: 13px;
      height: 13px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 0 3px rgba(245, 241, 232, 0.35);
      border: none;
      cursor: pointer;
    }

    #density-slider::-moz-range-thumb {
      width: 13px;
      height: 13px;
      border-radius: 50%;
      background: var(--accent);
      border: none;
      cursor: pointer;
    }

    #hint-text {
      pointer-events: auto;
      align-self: center;
      font-size: 0.78rem;
      color: var(--text-muted);
      text-align: center;
      max-width: 260px;
      margin-bottom: 4px;
      opacity: 0.85;
    }

    #hint-text code {
      font-family: "SF Mono", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono",
        "Courier New", monospace;
      font-size: 0.74rem;
      background: rgba(255, 255, 255, 0.08);
      padding: 2px 4px;
      border-radius: 4px;
    }

    @media (max-width: 768px) {
      #bottom-controls {
        gap: 6px;
        padding: 7px 10px;
      }
      #density-slider {
        width: 70px;
      }
      #hint-text {
        font-size: 0.72rem;
        max-width: 220px;
      }
    }
  </style>
</head>
<body>
<div id="app">
  <div id="three-container"></div>
  <video id="input-video" playsinline muted></video>

  <div id="ui-overlay">
    <div id="top-left-chip">
      <span class="dot"></span>
      <span>Gesture Starfield</span>
    </div>

    <div style="display:flex;flex-direction:column;align-items:center;">
      <div id="hint-text">
        <strong>Camera</strong>: show an open hand near the screen to push the stars away.<br/>
        <strong>No camera</strong>: move your <code>mouse</code> over the canvas &amp; click-drag.
      </div>

      <div id="bottom-controls">
        <button id="camera-btn" class="btn">
          <span>ðŸ“·</span>
          <span id="camera-label">Camera off</span>
        </button>

        <div id="density-group">
          <span>Density</span>
          <input id="density-slider" type="range" min="8000" max="42000" step="2000" />
        </div>

        <button id="reset-btn" class="btn">
          <span>âŸ³</span>
          <span>Reset</span>
        </button>

        <button id="snap-btn" class="btn">
          <span>ðŸ“¸</span>
          <span>PNG</span>
        </button>
      </div>
    </div>
  </div>
</div>

<script>
  // ==========================================================
  // CORE THREE + BLOOM SETUP
  // ==========================================================
  let scene, camera, renderer, composer, renderPass, bloomPass;
  let particleSystem, geometry, material;
  let positions, velocities, seeds;
  let particleCount = 26000;

  let isLowPowerDevice = false;
  detectLowPowerDevice();

  const uniforms = {
    uTime: { value: 0 },
    uPointSize: { value: 1.3 },
    uNoiseStrength: { value: 0.7 },
    uColor: { value: new THREE.Color(0xf5f1e8) }
  };

  const HAND_MAX = 2;
  const handForces = [];
  for (let i = 0; i < HAND_MAX; i++) {
    handForces.push({
      active: false,
      x: 0,
      y: 0,
      z: 0,
      tension: 0
    });
  }

  let lastTime = performance.now();
  let manualForceActive = false;
  let manualForcePos = { x: 0, y: 0, z: 0 };

  const densitySlider = document.getElementById("density-slider");
  const cameraBtn = document.getElementById("camera-btn");
  const cameraLabel = document.getElementById("camera-label");
  const resetBtn = document.getElementById("reset-btn");
  const snapBtn = document.getElementById("snap-btn");
  const videoElement = document.getElementById("input-video");

  let hands = null;
  let gestureControlEnabled = false;
  let videoStream = null;
  let handDetectionActive = false;
  let lastTensionAverage = null;
  let lastSnapTime = 0;

  function detectLowPowerDevice() {
    const ua = navigator.userAgent || "";
    const isMobile = /Android|iPhone|iPad|iPod|Mobi/i.test(ua);
    const fewCores =
      typeof navigator.hardwareConcurrency === "number" &&
      navigator.hardwareConcurrency <= 4;
    isLowPowerDevice = isMobile || fewCores;
    if (isLowPowerDevice) {
      particleCount = 16000;
    }
  }

  function init() {
    const container = document.getElementById("three-container");

    scene = new THREE.Scene();
    scene.fog = null;

    camera = new THREE.PerspectiveCamera(
      55,
      window.innerWidth / window.innerHeight,
      0.1,
      50
    );
    camera.position.set(0, 0, 3.2);

    renderer = new THREE.WebGLRenderer({
      antialias: false,
      preserveDrawingBuffer: true
    });
    const maxPixelRatio = isLowPowerDevice ? 1.5 : 2;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, maxPixelRatio));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 1);
    container.appendChild(renderer.domElement);

    composer = new THREE.EffectComposer(renderer);
    renderPass = new THREE.RenderPass(scene, camera);
    composer.addPass(renderPass);

    const bloomStrength = isLowPowerDevice ? 1.2 : 1.7;
    const bloomRadius = 0.42;
    const bloomThreshold = 0.0;

    bloomPass = new THREE.UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      bloomStrength,
      bloomRadius,
      bloomThreshold
    );
    composer.addPass(bloomPass);

    window.addEventListener("resize", onWindowResize);
    buildParticles(particleCount);
    initHandsModel();
    setupUI();
    setupInteractions();

    lastTime = performance.now();
    animate();
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
    bloomPass.setSize(window.innerWidth, window.innerHeight);
  }

  // ==========================================================
  // PARTICLE FIELD â€“ STARFIELD STYLE
  // ==========================================================
  function buildParticles(count) {
    particleCount = count;
    positions = new Float32Array(count * 3);
    velocities = new Float32Array(count * 3);
    seeds = new Float32Array(count);

    for (let i = 0; i < count; i++) {
      const idx = i * 3;
      const u = Math.random();
      const v = Math.random();
      const theta = 2 * Math.PI * u;
      const phi = Math.acos(2 * v - 1);
      const r = Math.pow(Math.random(), 1.6) * 1.4;

      const x = r * Math.sin(phi) * Math.cos(theta);
      const y = r * Math.cos(phi);
      const z = r * Math.sin(phi) * Math.sin(theta);

      positions[idx] = x;
      positions[idx + 1] = y;
      positions[idx + 2] = z;

      velocities[idx] = 0;
      velocities[idx + 1] = 0;
      velocities[idx + 2] = 0;

      seeds[i] = Math.random();
    }

    if (geometry) geometry.dispose();

    geometry = new THREE.BufferGeometry();
    geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute("aSeed", new THREE.BufferAttribute(seeds, 1));

    const vertexShader = `
      attribute float aSeed;
      uniform float uTime;
      uniform float uPointSize;
      uniform float uNoiseStrength;

      float hash(float n) {
        return fract(sin(n) * 43758.5453);
      }

      void main() {
        vec3 pos = position;

        float n = hash(aSeed * 91.7 + uTime * 0.07);
        n = n * 2.0 - 1.0;
        pos += normalize(pos + 0.0001) * n * uNoiseStrength * 0.03;

        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
        float size = uPointSize * (280.0 / -mvPosition.z);
        gl_PointSize = size;
        gl_Position = projectionMatrix * mvPosition;
      }
    `;

    const fragmentShader = `
      uniform vec3 uColor;

      void main() {
        vec2 coord = gl_PointCoord - 0.5;
        float d = length(coord);

        float alpha = smoothstep(0.5, 0.0, d);
        if (d > 0.5) discard;

        float core = smoothstep(0.25, 0.0, d);
        vec3 col = uColor * (0.6 + 0.4 * core);

        gl_FragColor = vec4(col, alpha);
      }
    `;

    material = new THREE.ShaderMaterial({
      uniforms,
      vertexShader,
      fragmentShader,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    if (particleSystem) scene.remove(particleSystem);
    particleSystem = new THREE.Points(geometry, material);
    scene.add(particleSystem);
  }

  function resetParticles() {
    buildParticles(particleCount);
  }

  // ==========================================================
  // HAND TRACKING â€“ LOCAL FORCE FIELD
  // ==========================================================
  function initHandsModel() {
    hands = new Hands({
      locateFile: (file) =>
        `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
      maxNumHands: 2,
      modelComplexity: 1,
      minDetectionConfidence: 0.6,
      minTrackingConfidence: 0.5
    });

    hands.onResults(onHandResults);
  }

  async function startGestureCamera() {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      cameraLabel.textContent = "No camera";
      gestureControlEnabled = false;
      cameraBtn.classList.remove("btn-toggle-on");
      return;
    }

    try {
      cameraLabel.textContent = "Requestingâ€¦";

      videoStream = await navigator.mediaDevices.getUserMedia({
        video: { width: 640, height: 480 }
      });

      videoElement.srcObject = videoStream;
      await videoElement.play();

      gestureControlEnabled = true;
      cameraLabel.textContent = "Camera on";
      cameraBtn.classList.add("btn-toggle-on");

      handDetectionActive = true;
      requestAnimationFrame(handFrameLoop);
    } catch (err) {
      console.error("Camera error:", err);
      gestureControlEnabled = false;
      cameraLabel.textContent = "Denied";
      cameraBtn.classList.remove("btn-toggle-on");
    }
  }

  function stopGestureCamera() {
    handDetectionActive = false;
    gestureControlEnabled = false;
    if (videoStream) {
      videoStream.getTracks().forEach(t => t.stop());
      videoStream = null;
    }
    cameraLabel.textContent = "Camera off";
    cameraBtn.classList.remove("btn-toggle-on");
    handForces.forEach(h => (h.active = false));
  }

  async function handFrameLoop() {
    if (!handDetectionActive || !gestureControlEnabled) return;
    if (videoElement.readyState >= 2) {
      await hands.send({ image: videoElement });
    }
    requestAnimationFrame(handFrameLoop);
  }

  function onHandResults(results) {
    if (!gestureControlEnabled) return;

    const landmarksList = results.multiHandLandmarks || [];
    handForces.forEach(h => (h.active = false));

    if (!landmarksList.length) {
      lastTensionAverage = null;
      return;
    }

    let tensionSum = 0;

    for (let h = 0; h < Math.min(landmarksList.length, HAND_MAX); h++) {
      const lm = landmarksList[h];
      const hf = handForces[h];

      const wrist = lm[0];
      const indexMcp = lm[5];
      const centerX = (wrist.x + indexMcp.x) * 0.5;
      const centerY = (wrist.y + indexMcp.y) * 0.5;

      const ndcX = (centerX - 0.5) * 2.1;
      const ndcY = (0.5 - centerY) * 2.1;
      const z = 0.0;

      const indexTip = lm[8];
      const pinkyTip = lm[20];
      const span = Math.hypot(indexTip.x - pinkyTip.x, indexTip.y - pinkyTip.y);
      const tension = clamp((span - 0.03) / 0.22, 0, 1);

      hf.active = true;
      hf.x = ndcX;
      hf.y = ndcY;
      hf.z = z;
      hf.tension = tension;

      tensionSum += tension;
    }

    const avgTension = tensionSum / landmarksList.length;
    const now = performance.now();

    if (
      lastTensionAverage !== null &&
      lastTensionAverage > 0.65 &&
      avgTension < 0.25 &&
      now - lastSnapTime > 900
    ) {
      triggerGlobalBurst();
      lastSnapTime = now;
    }

    lastTensionAverage = avgTension;
  }

  // ==========================================================
  // UI & MANUAL CONTROL
  // ==========================================================
  function setupUI() {
    densitySlider.value = particleCount;

    densitySlider.addEventListener("input", () => {
      const newCount = parseInt(densitySlider.value, 10);
      buildParticles(newCount);
    });

    cameraBtn.addEventListener("click", () => {
      if (gestureControlEnabled) {
        stopGestureCamera();
      } else {
        startGestureCamera();
      }
    });

    resetBtn.addEventListener("click", () => resetParticles());

    snapBtn.addEventListener("click", () => {
      try {
        const dataURL = renderer.domElement.toDataURL("image/png");
        const link = document.createElement("a");
        link.href = dataURL;
        link.download = "gesture-starfield.png";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      } catch (e) {
        console.error("Capture failed:", e);
      }
    });
  }

  function setupInteractions() {
    const canvas = renderer.domElement;

    function updateManualForceFromEvent(e) {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) / rect.width;
      const y = (e.clientY - rect.top) / rect.height;

      manualForcePos.x = (x - 0.5) * 2.1;
      manualForcePos.y = (0.5 - y) * 2.1;
      manualForcePos.z = 0.0;
    }

    canvas.addEventListener("pointerdown", (e) => {
      if (!gestureControlEnabled) {
        manualForceActive = true;
        updateManualForceFromEvent(e);
      }
    });

    canvas.addEventListener("pointermove", (e) => {
      if (!gestureControlEnabled && manualForceActive) {
        updateManualForceFromEvent(e);
      }
    });

    window.addEventListener("pointerup", () => {
      manualForceActive = false;
    });

    window.addEventListener("keydown", (e) => {
      if (e.key.toLowerCase() === "c") cameraBtn.click();
    });
  }

  // ==========================================================
  // PHYSICS LOOP â€“ LOCAL REPULSION + SPRING BACK
  // ==========================================================
  function triggerGlobalBurst() {
    const burstStrength = 2.2;
    for (let i = 0; i < particleCount; i++) {
      const idx = i * 3;
      const x = positions[idx];
      const y = positions[idx + 1];
      const z = positions[idx + 2];

      const len = Math.sqrt(x * x + y * y + z * z) + 0.0001;
      const dirX = x / len;
      const dirY = y / len;
      const dirZ = z / len;

      const s = (Math.random() * 0.6 + 0.4) * burstStrength;

      velocities[idx] += dirX * s;
      velocities[idx + 1] += dirY * s;
      velocities[idx + 2] += dirZ * s;
    }

    uniforms.uPointSize.value = 1.6;
    uniforms.uNoiseStrength.value = 1.0;
    setTimeout(() => {
      uniforms.uPointSize.value = 1.3;
      uniforms.uNoiseStrength.value = 0.7;
    }, 260);
  }

  function animate() {
    requestAnimationFrame(animate);

    const now = performance.now();
    const dt = Math.min((now - lastTime) / 1000, 1 / 30);
    lastTime = now;

    uniforms.uTime.value += dt;
    updateParticlePhysics(dt);

    if (geometry) geometry.attributes.position.needsUpdate = true;
    composer.render();
  }

  function updateParticlePhysics(dt) {
    if (!positions || !velocities) return;

    const activeHands = [];

    if (gestureControlEnabled) {
      for (let h = 0; h < HAND_MAX; h++) {
        const hf = handForces[h];
        if (!hf.active) continue;

        const tension = hf.tension;
        const radius = 0.35 + tension * 0.75;
        const strength = 7.0 + tension * 11.0;

        activeHands.push({
          x: hf.x,
          y: hf.y,
          z: hf.z,
          radius,
          strength
        });
      }
    }

    if (!gestureControlEnabled && manualForceActive) {
      activeHands.push({
        x: manualForcePos.x,
        y: manualForcePos.y,
        z: manualForcePos.z,
        radius: 0.6,
        strength: 12.0
      });
    }

    const springStrength = 0.55;
    const damping = 0.94;

    for (let i = 0; i < particleCount; i++) {
      const idx = i * 3;
      let px = positions[idx];
      let py = positions[idx + 1];
      let pz = positions[idx + 2];

      let vx = velocities[idx];
      let vy = velocities[idx + 1];
      let vz = velocities[idx + 2];

      vx += -px * springStrength * dt;
      vy += -py * springStrength * dt;
      vz += -pz * springStrength * dt;

      for (let h = 0; h < activeHands.length; h++) {
        const hf = activeHands[h];
        const dx = px - hf.x;
        const dy = py - hf.y;
        const dz = pz - hf.z;
        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) + 0.0001;

        if (dist < hf.radius) {
          const factor = (hf.radius - dist) / hf.radius;
          const dirX = dx / dist;
          const dirY = dy / dist;
          const dirZ = dz / dist;

          const accel = hf.strength * factor;

          vx += dirX * accel * dt;
          vy += dirY * accel * dt;
          vz += dirZ * accel * dt;
        }
      }

      vx *= damping;
      vy *= damping;
      vz *= damping;

      px += vx * dt;
      py += vy * dt;
      pz += vz * dt;

      positions[idx] = px;
      positions[idx + 1] = py;
      positions[idx + 2] = pz;

      velocities[idx] = vx;
      velocities[idx + 1] = vy;
      velocities[idx + 2] = vz;
    }
  }

  function clamp(v, min, max) {
    return v < min ? min : (v > max ? max : v);
  }

  window.addEventListener("DOMContentLoaded", init);
</script>
</body>
</html>
